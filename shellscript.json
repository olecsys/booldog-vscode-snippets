{
  "booldog:shell:skeleton": {
    "prefix": "booldog:shell:skeleton",
    "body": [
      "#!/bin/bash",
      "function read_options() {",
      "  g_opt_ind=0",
      "  while getopts \"yYnN\" opt; do",
      "    glob_opt_args[\\$g_opt_ind]=\\$opt",
      "    g_opt_ind=\\$((\\$g_opt_ind+1))",
      "  done",
      "  g_opt_ind=0",
      "}",
      "",
      "function main() {",
      "  local old_dir=\"`pwd`/`basename \"\\$0\"`\"",
      "  old_dir=`dirname \"\\$old_dir\"`",
      "  cd \"`dirname \"\\$0\"`\"",
      "  local script_dir=\"`pwd`/`basename \"\\$0\"`\"",
      "  script_dir=`dirname \"\\$script_dir\"`",
      "  cd \"\\$old_dir\"",
      "  read_options $@",
      "",
      "  local red='\\e[0;31m'",
      "  local green='\\e[0;32m'",
      "  local nocolor='\\e[0m'",
      "",
      "  __funcerror=",
      "  __funccanceled=0",
      "  __funcfailed=0",
      "",
      "  if [ \\$__funcfailed -eq 0 ] && [ \\$__funccanceled -eq 0 ]; then",
      "    ${2:echo \"Some action\"} || __funcfailed=1",
      "  fi",
      "",
      "  if [ \\$__funccanceled -eq 1 ]; then",
      "    echo -e \"\\${red}${1:Script process name} is canceled\\${nocolor}\" 1>&2",
      "  else",
      "    if [ \\$__funcfailed -eq 0 ]; then",
      "      echo -e \"\\${green}${1:Script process name} is succeeded\\${nocolor}\"",
      "    else",
      "      if ! [ -z \"\\$__funcerror\" ]; then",
      "        echo -e \"\\${red}\\$__funcerror\\${nocolor}\" 1>&2",
      "      else",
      "        echo -e \"\\${red}${1:Script process name} is failed\\${nocolor}\" 1>&2",
      "      fi",
      "    fi",
      "  fi",
      "  cd \"\\$old_dir\"",
      "}",
      "main $@",
      "if [ \\$__funcfailed -eq 0 ]; then",
      "  exit 0",
      "else",
      "  exit 1",
      "fi"
    ],
    "description": "Shell file skeleton"
  },
  "booldog:shell:wait-for-non-empty-function": {
    "prefix": "booldog:shell:wait-for-non-empty-function",
    "body": [
      "function wait_for_non_empty() {",
      "  local question=\\$1",
      "  echo -e \"\\$question\"",
      "  read __funcresult </dev/tty",
      "  while [ -z \"\\$__funcresult\" ]",
      "  do",
      "    echo -e \"\\$question\"",
      "    read __funcresult </dev/tty",
      "  done",
      "}"
    ],
    "description": "Shell function that is waiting for non empty string, variable $__funcresult contains function result"
  },
  "booldog:shell:script-confirmation-question": {
    "prefix": "booldog:shell:script-confirmation-question",
    "body": [
      "local question=\"Are you sure you want to ${1:execute script}?(Y/n)\"",
      "wait_for_yes_no \"\\$question\" \"${2:Y}\"",
      "local __funccanceled=\"\\$__funcresult\"",
      "if [ \"\\$__funccanceled\" = \"Y\" ] || [ \"\\$__funccanceled\" = \"y\" ]; then",
      "  __funccanceled=0",
      "else",
      "  __funccanceled=1",
      "fi"
    ],
    "description": "Confirmation of the script execution"
  },
  "booldog:shell:wait-for-yes-no-function": {
    "prefix": "booldog:shell:wait-for-yes-no-function",
    "body": [
      "function wait_for_yes_no() {",
      "  local question=\\$1",
      "  local default_value=\\$2",
      "  echo -e \"\\$question\"",
      "  case \\${glob_opt_args[\\$g_opt_ind]} in",
      "  \"y\" | \"Y\" | \"n\" | \"N\" )",
      "    __funcresult=\"\\${glob_opt_args[\\$g_opt_ind]}\"",
      "    echo \"\\$__funcresult\"",
      "    g_opt_ind=\\$((\\$g_opt_ind+1))",
      "    return ;;",
      "  *) ;;",
      "  esac",
      "  read __funcresult </dev/tty",
      "  while ! [ -z \"\\$__funcresult\" ] && ! [ \"\\$__funcresult\" = \"n\" ] \\",
      "    && ! [ \"\\$__funcresult\" = \"N\" ] && ! [ \"\\$__funcresult\" = \"y\" ] \\",
      "    && ! [ \"\\$__funcresult\" = \"Y\" ]",
      "  do",
      "  echo -e \"Please enter N, n, y or Y",
      "\\$question\"",
      "    read __funcresult </dev/tty",
      "  done",
      "  if [ -z \"\\$__funcresult\" ]; then",
      "    __funcresult=\\$default_value",
      "  fi",
      "}"
    ],
    "description": "Shell function that is waiting for Yes/No enter, variable $__funcresult contains function result"
  },
  "booldog:shell:escape-path-variable-for-sed": {
    "prefix": "booldog:shell:escape-path-variable-for-sed",
    "body": [
      "local ${1:VARNAME}_ESC=\\$(sed 's/[\\*\\.&]/\\\\&/g' <<<\"\\$${1:VARNAME}\")",
      "local ${1:VARNAME}_ESC=\\$(sed 's/[\\/]/\\\\&/g' <<<\"\\$${1:VARNAME}_ESC\")"
    ],
    "description": "Escape file/directory path variable for `sed` processing"
  },
  "booldog:shell:if-error-or-action": {
    "prefix": "booldog:shell:if-error-or-action",
    "body": [
      "if [ \\$__funcfailed -eq 0 ] && [ \\$__funccanceled -eq 0 ]; then",
      "  ${1:echo \"Some action\"} || __funcfailed=1",
      "fi"
    ],
    "description": "Shell action expression with previous error and cancelation checking"
  },
  "booldog:shell:sed-delete-line": {
    "prefix": "booldog:shell:sed-delete-line",
    "body": [
      "sed -i \"/${1:^@reboot\\s\\+nohup\\s\\+\\\".*\\/bin\\/reboot.sh\\\"}/d\" \\",
      "  ${2:/tmp/file_to_change}"
    ],
    "description": "Shell sed command that delete line with Regex expression match"
  },
  "booldog:shell:check-system-user-exists": {
    "prefix": "booldog:shell:check-system-user-exists",
    "body": [
      "local ${2:__user_exists}=1",
      "id -u ${1:USERNAME} || ${2:__user_exists}=0"
    ],
    "description": "Shell command to check system user existence"
  },
  "booldog:shell:check-file-exists": {
    "prefix": "booldog:shell:check-file-exists",
    "body": [
      "if [ -e \"${1:/tmp/file_to_check}\" ]; then",
      "  ${2:echo \"File exists\"}",
      "fi"
    ],
    "description": "Shell expression to check file existence"
  },
  "booldog:shell:add-system-user": {
    "prefix": "booldog:shell:add-system-user",
    "body": [
      "useradd -d \"${2:/home/USERHOMEDIR}\" -s /bin/bash -m ${1:USERNAME}"
    ],
    "description": "Shell command to add new system user with home directory"
  },
  "booldog:shell:sed-replace-line": {
    "prefix": "booldog:shell:sed-replace-line",
    "body": [
      "sed -i \\",
      "  \"s/${1:^EXEC_DIR=\\\".*\\\".*/EXEC_DIR=\\\"\\$OVERPASS_DIR_ESC\\/bin\\\" # generated by overpass_api.sh}/\" \\",
      "  ${2:/tmp/file_to_change}"
    ],
    "description": "Shell sed command that replace line with new string"
  },
  "booldog:shell:jupyter-config": {
    "prefix": "booldog:shell:jupyter-config",
    "body": [
      "#!/bin/bash",
      "function read_options() {",
      "  g_opt_ind=0",
      "  while getopts \"yYnN\" opt; do",
      "    glob_opt_args[\\$g_opt_ind]=\\$opt",
      "    g_opt_ind=\\$((\\$g_opt_ind+1))",
      "  done",
      "  g_opt_ind=0",
      "}",
      "",
      "function main() {",
      "  local old_dir=\"`pwd`/`basename \"\\$0\"`\"",
      "  old_dir=`dirname \"\\$old_dir\"`",
      "  cd \"`dirname \"\\$0\"`\"",
      "  local script_dir=\"`pwd`/`basename \"\\$0\"`\"",
      "  script_dir=`dirname \"\\$script_dir\"`",
      "  cd \"\\$old_dir\"",
      "  local red='\\e[0;31m'",
      "  local green='\\e[0;32m'",
      "  local nocolor='\\e[0m'",
      "",
      "  __funcerror=",
      "  __funccanceled=0",
      "  __funcfailed=0",
      "",
      "  if [ -z \"\\${MAKEFILE_DIR}\" ]; then",
      "    if [ -e \"\\${script_dir}/../Makefile\" ]; then",
      "      local MAKEFILE_DIR=\\${script_dir}/..",
      "    fi",
      "    if [ -e \"\\${script_dir}/Makefile\" ]; then",
      "      local MAKEFILE_DIR=\\${script_dir}",
      "    fi",
      "  fi",
      "",
      "  if [ -e \"\\${script_dir}/../config.env\" ]; then",
      "    eval \\$(cat \"\\${script_dir}/../config.env\" | sed 's/\\s/\\\\\\\\ /g' | sed 's/^/export /')",
      "  fi",
      "",
      "  if [ -z \"\\${JUPYTER_CONFIG_PATH}\" ]; then",
      "    local JUPYTER_CONFIG_PATH=\\${script_dir}/../jupyter_notebook_config.json",
      "  fi  ",
      "  if [ \\$__funcfailed -eq 0 ] && [ \\$__funccanceled -eq 0 ]; then",
      "    jupyter notebook password --config=\"\\${JUPYTER_CONFIG_PATH}\" \\",
      "      || __funcfailed=1",
      "  fi",
      "  if [ \\$__funcfailed -eq 0 ] && [ \\$__funccanceled -eq 0 ]; then",
      "    chmod 777 \"\\${JUPYTER_CONFIG_PATH}\" || __funcfailed=1",
      "  fi",
      "",
      "  if [ \\$__funccanceled -eq 1 ]; then",
      "    echo -e \"\\${red}Jupyter configuration process is canceled\\${nocolor}\" 1>&2",
      "  else",
      "    if [ \\$__funcfailed -eq 0 ]; then",
      "      echo -e \"\\${green}Jupyter configuration process is succeeded\\${nocolor}\"",
      "    else",
      "      if ! [ -z \"\\$__funcerror\" ]; then",
      "        echo -e \"\\${red}\\$__funcerror\\${nocolor}\" 1>&2",
      "      else",
      "        echo -e \"\\${red}Jupyter configuration process is failed\\${nocolor}\" 1>&2",
      "      fi",
      "    fi",
      "  fi",
      "  cd \"\\$old_dir\"",
      "}",
      "main \\$@",
      "if [ \\$__funcfailed -eq 0 ]; then",
      "  exit 0",
      "else",
      "  exit 1",
      "fi"
    ],
    "description": "Shell script that uses `config.env` and helps to tune Jupyter Notebook settings"
  }
}